/*C - Align
時間制限 : 2sec / メモリ制限 : 1024MB

配点 : 400 点

問題文
整数が N 個与えられます。i 個目の整数は Ai です。 これらを好きな順に一列に並べるとき、隣り合う要素の差の合計の最大値を求めてください。

制約
2≤N≤105
1≤Ai≤109
入力はすべて整数である*/

#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main(){
  int n;
  int sum=0;
  cin>>n;
  vector<int> ve(n);

  

  for (int i = 0; i < n; ++i)
  {
    cin>>ve[i];
  }

  sort(ve.begin(),ve.end());

  for (int i = 0; i < n; ++i)
  {
    cout<<ve[i];
  }

  int max,min;

  max=*max_element(ve.begin(),ve.end());

  cout<<max<<endl;

  return 0;
}   


/*A.

作る列を p1, ..., pN としたとき、pi−1 < pi < pi+1 や pi−1 > pi > pi+1 となるような i は存在しないとし
てよいです。これは、そのほかの要素の相対的な順序を保ったまま pi を列の末尾に移動しても、隣り合う項
の差の絶対値の和は減らないことによります。末尾への移動操作で新たにこのような箇所ができる可能性もあ
りますが、その時は末尾から二番目の要素を再び末尾に移動してやることで、最大化したい値を減らさずにこ
のような箇所をなくすことができます。
さて、ありうるパターンは p1 ≥ p2 ≤ p3 ≥ ... か p1 ≤ p2 ≥ p3 ≤ ... のいずれかになります。これら両方の
パターンを試して大きい方を出力することにしましょう。対称性より、前者の場合のみ考えます。
このとき、隣り合う項の差の絶対値の和は、(p1 − p2) + (p3 − p2) + (p3 − p4) + (p5 − p4) + ... です。すな
わち、各 i に対し、pi が最大化したい値に何回足される (もしくは、引かれる) かが定まります。
たくさん足される値を大きく、たくさん引かれる値を小さくすることでこの値は最大化できるので、各 pi
につく係数を見て、大きい順に大きい要素を割り当てていけばよいです。よってこの問題を解くことができま
した。*/